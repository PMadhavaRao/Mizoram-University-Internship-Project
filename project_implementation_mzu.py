# -*- coding: utf-8 -*-
"""project_implementation_mzu

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GTvKNHSdOXgfIV9HsqBO3-efg5fuyR5q
"""

import pandas as pd
import os
# Load the CSV file
csv_path = '/content/project_major.csv'
df = pd.read_csv(csv_path)

# Assign labels: first 474 images are healthy (label = '1'), remaining 291 are unhealthy (label = '0')
df['label'] = ['1'] * 474 + ['0'] * 291

# Replace backslashes with forward slashes in the image paths
df['image_path'] = df['image_path'].str.replace('\\', '/')

# Function to correct paths
def correct_path(image_path):
    base_dir = '/content/drive/MyDrive/both_images2'  # Adjust this based on your environment
    filename = os.path.basename(image_path)  # Extract the filename
    return os.path.join(base_dir, filename)  # Construct the new path

# Apply the function to the 'image_path' column
df['image_path'] = df['image_path'].apply(correct_path)

# Verify the changes
print(df.head())

# Save the updated CSV (optional)
df.to_csv('/content/project_corrected.csv', index=False)

# Check if the new paths are valid
invalid_paths = [path for path in df['image_path'] if not os.path.exists(path)]
print(f"Number of invalid paths: {len(invalid_paths)}")

# Display some invalid paths if there are any
for path in invalid_paths[:10]:
    print(path)

if len(invalid_paths) > 0:
    print("There are still invalid paths. Please check the directory and filenames.")
else:
    print("All paths are valid.")

from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Ensure labels are strings
df['label'] = df['label'].astype(str)

# Split the data into training and validation sets
train_df, val_df = train_test_split(df, test_size=0.2, random_state=42)

# Image data generators
train_datagen = ImageDataGenerator(rescale=1./255)
val_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_dataframe(
    train_df,
    x_col='image_path',
    y_col='label',
    target_size=(128, 128),
    batch_size=32,
    class_mode='binary'
)

val_generator = val_datagen.flow_from_dataframe(
    val_df,
    x_col='image_path',
    y_col='label',
    target_size=(128, 128),
    batch_size=32,
    class_mode='binary'
)



from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

# Build the CNN model
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 3)),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(512, activation='relu'),
    Dropout(0.5),
    Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
print("Model built and compiled.")

# Train the model
history = model.fit(
    train_generator,
    validation_data=val_generator,
    epochs=10
)

# Save the model
model.save('/content/scalp_psoriasis_model.h5')
print("Model trained and saved.")

import matplotlib.pyplot as plt

# Plot training & validation accuracy values
plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Model accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper left')

# Plot training & validation loss values
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper left')

plt.show()

import numpy as np
from sklearn.metrics import confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# Make predictions on the validation set
val_predictions = model.predict(val_generator)
val_predictions = np.where(val_predictions > 0.5, 1, 0)  # Convert probabilities to class labels

# Get true labels
val_true_labels = val_generator.classes

# Compute the confusion matrix
conf_matrix = confusion_matrix(val_true_labels, val_predictions)

# Print the confusion matrix
print("Confusion Matrix:")
print(conf_matrix)

# Plot the heatmap
import seaborn as sns

plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['Unhealthy', 'Healthy'], yticklabels=['Unhealthy', 'Healthy'])
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.title('Confusion Matrix Heatmap')
plt.show()



#prediction of model with user input
from tensorflow.keras.preprocessing import image
import numpy as np

def classify_image(img_path, model):
    img = image.load_img(img_path, target_size=(128, 128))
    img_array = image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    prediction = model.predict(img_array)
    print("your scalp is",end=" ")
    if prediction < 0.5:
        print("Unhealthy")
    else:
        print("Healthy")

# Example usage
classify_image('/content/healthy (10).jpg', model)

#prediction of model with user input
from tensorflow.keras.preprocessing import image
import numpy as np

def classify_image(img_path, model):
    img = image.load_img(img_path, target_size=(128, 128))
    img_array = image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    prediction = model.predict(img_array)
    print("your scalp is",end=" ")
    if prediction < 0.5:
        print("Unhealthy")
    else:
        print("Healthy")

# Example usage
classify_image('/content/download 2.jpeg', model)

import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import Model
from PIL import Image

def apply_model_and_display(img_path, model):
    # Load the original image
    original_img = Image.open(img_path).convert('RGB')
    original_size = original_img.size

    # Preprocess the image for the model
    target_size = (128, 128)
    img = image.load_img(img_path, target_size=target_size)
    img_array = image.img_to_array(img) / 255.0  # Normalize
    img_array = np.expand_dims(img_array, axis=0)

    # Make prediction
    prediction = model.predict(img_array)


    layer_name = 'conv2d_2'
    intermediate_layer_model = Model(inputs=model.input,
                                     outputs=model.get_layer(layer_name).output)
    intermediate_output = intermediate_layer_model.predict(img_array)


    heatmap = np.mean(intermediate_output[0], axis=-1)

    # Normalize the heatmap
    heatmap -= heatmap.min()
    heatmap /= heatmap.max()

    # Resize heatmap to original image size
    heatmap = np.uint8(255 * heatmap)
    heatmap = Image.fromarray(heatmap).resize(original_size, Image.ANTIALIAS)
    heatmap = np.array(heatmap)

    # Apply colormap to heatmap
    import cv2
    heatmap_colored = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
    heatmap_colored = cv2.cvtColor(heatmap_colored, cv2.COLOR_BGR2RGB)

    # Superimpose the heatmap on original image
    superimposed_img = heatmap_colored * 0.4 + np.array(original_img)

    # Display the original and processed images
    plt.figure(figsize=(15, 5))

    # Original image
    plt.subplot(1, 3, 1)
    plt.imshow(original_img)
    plt.title('Original Image')
    plt.axis('off')

    # Heatmap
    plt.subplot(1, 3, 2)
    plt.imshow(heatmap, cmap='jet')
    plt.title('Model Focus Heatmap')
    plt.axis('off')

    # Superimposed image
    plt.subplot(1, 3, 3)
    plt.imshow(np.uint8(superimposed_img))
    plt.title('Overlay of Heatmap on Image')
    plt.axis('off')

    plt.show()

    # Print the prediction result
    print("scalp is", end=" ")
    if prediction < 0.5:
        print("Unhealthy")
    else:
        print("Healthy")

# Example usage
apply_model_and_display('/content/healthy (36).jpg', model)

import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import Model
from PIL import Image

def apply_model_and_display(img_path, model):
    # Load the original image
    original_img = Image.open(img_path).convert('RGB')
    original_size = original_img.size

    # Preprocess the image for the model
    target_size = (128, 128)
    img = image.load_img(img_path, target_size=target_size)
    img_array = image.img_to_array(img) / 255.0  # Normalize
    img_array = np.expand_dims(img_array, axis=0)

    # Make prediction
    prediction = model.predict(img_array)

    # Extract intermediate layer outputs to visualize model focus
    # Let's focus on the last convolutional layer
    # Adjust 'conv2d_3' to the actual name of your last Conv2D layer
    layer_name = 'conv2d_2'  # Replace with your layer's actual name
    intermediate_layer_model = Model(inputs=model.input,
                                     outputs=model.get_layer(layer_name).output)
    intermediate_output = intermediate_layer_model.predict(img_array)

    # Process the intermediate output
    # Compute the mean of the feature maps to get a heatmap
    heatmap = np.mean(intermediate_output[0], axis=-1)

    # Normalize the heatmap
    heatmap -= heatmap.min()
    heatmap /= heatmap.max()

    # Resize heatmap to original image size
    heatmap = np.uint8(255 * heatmap)
    heatmap = Image.fromarray(heatmap).resize(original_size, Image.ANTIALIAS)
    heatmap = np.array(heatmap)

    # Apply colormap to heatmap
    import cv2
    heatmap_colored = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
    heatmap_colored = cv2.cvtColor(heatmap_colored, cv2.COLOR_BGR2RGB)

    # Superimpose the heatmap on original image
    superimposed_img = heatmap_colored * 0.4 + np.array(original_img)

    # Display the original and processed images
    plt.figure(figsize=(15, 5))

    # Original image
    plt.subplot(1, 3, 1)
    plt.imshow(original_img)
    plt.title('Original Image')
    plt.axis('off')

    # Heatmap
    plt.subplot(1, 3, 2)
    plt.imshow(heatmap, cmap='jet')
    plt.title('Model Focus Heatmap')
    plt.axis('off')

    # Superimposed image
    plt.subplot(1, 3, 3)
    plt.imshow(np.uint8(superimposed_img))
    plt.title('Overlay of Heatmap on Image')
    plt.axis('off')

    plt.show()

    # Print the prediction result
    print("scalp is", end=" ")
    if prediction < 0.5:
        print("Unhealthy")
    else:
        print("Healthy")

# Example usage with your specific image
apply_model_and_display('/content/unhealthy (32).jpg', model)

import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import Model
from PIL import Image

def apply_model_and_display(img_path, model):
    # Load the original image
    original_img = Image.open(img_path).convert('RGB')
    original_size = original_img.size

    # Preprocess the image for the model
    target_size = (128, 128)
    img = image.load_img(img_path, target_size=target_size)
    img_array = image.img_to_array(img) / 255.0  # Normalize
    img_array = np.expand_dims(img_array, axis=0)

    # Make prediction
    prediction = model.predict(img_array)

    # Extract intermediate layer outputs to visualize model focus
    # Let's focus on the last convolutional layer
    # Adjust 'conv2d_3' to the actual name of your last Conv2D layer
    layer_name = 'conv2d_2'  # Replace with your layer's actual name
    intermediate_layer_model = Model(inputs=model.input,
                                     outputs=model.get_layer(layer_name).output)
    intermediate_output = intermediate_layer_model.predict(img_array)

    # Process the intermediate output
    # Compute the mean of the feature maps to get a heatmap
    heatmap = np.mean(intermediate_output[0], axis=-1)

    # Normalize the heatmap
    heatmap -= heatmap.min()
    heatmap /= heatmap.max()

    # Resize heatmap to original image size
    heatmap = np.uint8(255 * heatmap)
    heatmap = Image.fromarray(heatmap).resize(original_size, Image.ANTIALIAS)
    heatmap = np.array(heatmap)

    # Apply colormap to heatmap
    import cv2
    heatmap_colored = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
    heatmap_colored = cv2.cvtColor(heatmap_colored, cv2.COLOR_BGR2RGB)

    # Superimpose the heatmap on original image
    superimposed_img = heatmap_colored * 0.4 + np.array(original_img)

    # Display the original and processed images
    plt.figure(figsize=(15, 5))

    # Original image
    plt.subplot(1, 3, 1)
    plt.imshow(original_img)
    plt.title('Original Image')
    plt.axis('off')

    # Heatmap
    plt.subplot(1, 3, 2)
    plt.imshow(heatmap, cmap='jet')
    plt.title('Model Focus Heatmap')
    plt.axis('off')

    # Superimposed image
    plt.subplot(1, 3, 3)
    plt.imshow(np.uint8(superimposed_img))
    plt.title('Overlay of Heatmap on Image')
    plt.axis('off')

    plt.show()

    # Print the prediction result
    print("scalp is", end=" ")
    if prediction < 0.5:
        print("Unhealthy")
    else:
        print("Healthy")

# Example usage with your specific image
apply_model_and_display('/content/sample1.jpg', model)

# Evaluate the model on the validation set
val_loss, val_accuracy = model.evaluate(val_generator)
val_loss,test_acc=model.evaluate(train_generator)

print(f"Validation Accuracy: {val_accuracy * 100:.2f}%")

print(f"test accruacy: {test_acc * 100:.2f}%")